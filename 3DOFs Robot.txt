l1 = 40
l2 = 50
l3 = 20
x_train = []
y_train = []

for t1 in [0,2*np.pi,0.01]:
  for t2 in [0,2*np.pi,0.01]:
    for t3 in [0,2*np.pi,0.01]:
      x = l1*math.cos(t1) + l2*math.cos(t1+t2) + l3*math.cos(t1+t2+t3)
      y = l1*math.sin(t1) + l2*math.sin(t1+t2) + l3*math.cos(t1+t2+t3)
      beta = (t1 + t2 + t3)*180/3.14
      x_train.append(np.array([x,y,beta]))
      y_train.append(np.array([t1,t2,t3]))
x_train = np.array(x_train)
y_train = np.array(y_train)
# Tao model
model1 = Sequential()
model1.add(Dense(512, activation = 'relu', input_shape = (3,)))
model1.add(Dense(512, activation = 'relu'))
model1.add(Dense(512, activation = 'relu'))
model1.add(Dense(512, activation = 'relu'))
model1.add(Dense(512, activation = 'relu'))
model1.add(Dense(512, activation = 'relu'))
model1.add(Dense(3,activation = 'softmax'))
model1.compile(loss='mae',optimizer = RMSprop(), metrics = 'acc')
his1 = model1.fit(x_train, y_train, batch_size = 128, epochs = 50, validation_split = 0.2, callbacks = [EarlyStopping(monitor='val_loss',patience = 10)])
# Predict
test = np.array([[50,5,10]])
t1 = model1.predict(test)[0][0]
t2 = model1.predict(test)[0][1]
t3 = model1.predict(test)[0][2]
x = l1*math.cos(t1) + l2*math.cos(t1+t2) + l3*math.cos(t1+t2+t3)
y = l1*math.sin(t1) + l2*math.sin(t1+t2) + l3*math.sin(t1+t2+t3)
beta = (t1 + t2 + t3)*180/3.14
print("t1=",t1,"t2=",t2, "t3=",t3)
